'use strict';
require('mocha-sinon');
var expect = require('chai').expect;
var assert = require('assert');
var nock = require('nock');
var fs = require('fs');
var path = require('path');
var scope;
var testEnvObj = require(path.join(__dirname, 'testEnv.json'));

function initNockSendMetrics(statusCode) {
  scope = nock(testEnvObj.VCAP_SERVICES['Auto-Scaling'][0]['credentials'])
    .put('/services/agent/report')
    .reply(statusCode, {});
}
describe('agent', function() {
  var utilObj;
  var serviceEnvObj, appEnvObj;
  var agentObj;
  var calculator;
  var enabledMetrics;
  var timestamp;
  beforeEach(function() {
    enabledMetrics = ["CPU", "Memory", "NODEJSHeapMemory", "ResponseTime", "EventLoopLatency", "Throughput"];
    delete require.cache[require.resolve('../../lib/util.js')];
    utilObj = require(path.join(__dirname, '../../lib/util.js'))();
    delete require.cache[require.resolve('../../lib/calculator.js')];
    calculator = require(path.join(__dirname, '../../lib/calculator.js'))();
    delete require.cache[require.resolve('../../lib/agent.js')];
    agentObj = require(path.join(__dirname, '../../lib/agent.js'))(enabledMetrics);

    timestamp = new Date().getTime();
    process.env.VCAP_SERVICES = JSON.stringify(testEnvObj.VCAP_SERVICES);
    process.env.VCAP_APPLICATION = JSON.stringify(testEnvObj.VCAP_APPLICATION);
    serviceEnvObj = utilObj.getServiceEnv();
    appEnvObj = utilObj.getApplicationEnv();

    // this.sinon.stub(console, 'log');
    this.sinon.stub(console, 'error');

  });
  context("shouldReport", function() {
    it("return true when metric_type in enabledMetrics", function() {
      var result = agentObj.shouldReport("CPU");
      expect(result).to.equal(true);
    });
    it("return false when metric_type in enabledMetrics", function() {
      var result = agentObj.shouldReport("NOTVALIDTYPE");
      expect(result).to.equal(false);
    });
  });
  context("createMetricsObj", function() {
    it("should return a metricObj with given parameters", function() {
      var metricObj = agentObj.createMetricsObj('nodejs', 'memory', 'memory', 1000, 'Bytes', '', timestamp);
      expect(metricObj.category).to.equal('nodejs');
      expect(metricObj.group).to.equal('memory');
      expect(metricObj.name).to.equal('memory');
      expect(metricObj.value).to.equal(1000);
      expect(metricObj.unit).to.equal('Bytes');
      expect(metricObj.desc).to.equal('');
      expect(metricObj.timestamp).to.equal(timestamp);
      assert.deepEqual(metricObj, { "category": "nodejs", "group": "memory", "name": "memory", "value": 1000, "unit": "Bytes", "desc": "", "timestamp": timestamp });
    })
  });
  context("constructMetrics", function() {
    var avgMetric;
    beforeEach(function() {
      calculator.latencyStats = {
        'count': 10,
        'sum': 100,
        'average': 1
      };
      calculator.httpStats = {
        'count': 10,
        'duration': 1000,
        'average': 1
      };
      calculator.memoryStats = {
        'count': 10,
        'sum': 100,
        'average': 1
      };
      calculator.cpuStats = {
        'count': 10,
        'sum': 1,
        'average': 1
      };
      calculator.heapStats = {
        'count': 10,
        'usedSum': 100,
        'usedAverage': 1,
        'committed': 10,
        'maxHeap': 10,
        'heapSizeLimit': 10,
        'maxSemiSpace': 10,
        'maxOldSpace': 10
      };
      calculator.throughputStats = {
        'lastCalculateTime': new Date().getTime() - 1000,
        'requestCount': 100,
        'throughput': 10
      };
      avgMetric = calculator.calculate();

    });
    it("should return a metric instance", function() {
      var result = agentObj.constructMetrics(appEnvObj, serviceEnvObj, avgMetric, timestamp);
      assert.deepEqual(result, {
        "appId": "testAppId",
        "appName": "testAppName",
        "appType": "nodejs",
        "serviceId": "testServiceId",
        "instanceIndex": 0,
        "instanceId": "testAppInstanceId",
        "timestamp": timestamp,
        "metrics": [
          { "category": "nodejs", "group": "ProcessCpuLoad", "name": "ProcessCpuLoad", "value": 10, "unit": "%%", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "memory", "name": "memory", "value": 10, "unit": "Bytes", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "HeapMemoryUsage", "name": "init", "value": 0, "unit": "Bytes", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "HeapMemoryUsage", "name": "used", "value": 10, "unit": "Bytes", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "HeapMemoryUsage", "name": "committed", "value": 10, "unit": "Bytes", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "HeapMemoryUsage", "name": "max", "value": 10, "unit": "Bytes", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "Web", "name": "responseTime", "value": 110, "unit": "ms", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "Web", "name": "eventloopLatency", "value": 10, "unit": "ms", "desc": "", "timestamp": timestamp },
          { "category": "nodejs", "group": "Web", "name": "throughput", "value": 100, "unit": "", "desc": "", "timestamp": timestamp }
        ]
      });
    });
  });
  context("refreshConfigration", function() {
    var configString;
    context("parameter:configString", function() {
      context("when configString is null", function() {
        beforeEach(function() {
          configString = null;
          agentObj.refreshConfigration(configString);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] configString is not found or empty')).to.be.true;
        });
      });
      context("when configString is undefined", function() {
        beforeEach(function() {
          configString = undefined;
          agentObj.refreshConfigration(configString);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] configString is not found or empty')).to.be.true;
        });
      });
      context("when configString is invalid json string", function() {
        beforeEach(function() {
          configString = "invalidJsonString";
          agentObj.refreshConfigration(configString);
        });
        it("should log the error", function() {
          expect(console.error.calledTwice).to.be.true;
          expect(console.error.calledWith("[Auto-Scaling Agent] Failed to parse server configuration:" + configString)).to.be.true;
        });
      });
    });
    context("when no reportInterval in config", function() {
      beforeEach(function() {
        var configObj = { "metricsConfig": { "agent": ["CPU", "MEMORY"] } };
        agentObj.reportInterval = 20000;
        configString = JSON.stringify(configObj);
        agentObj.refreshConfigration(configString);
      });
      it("should keep agent's reportInterval", function() {
        expect(agentObj.reportInterval).to.equal(20000);
      });
    });
    context("when no metricsConfig in config", function() {
      beforeEach(function() {
        var configObj = { "reportInterval": 10 };
        agentObj.enabledMetrics = new Set(["CPU", "MEMORY"]);
        agentObj.isAgentEnabled = true;
        configString = JSON.stringify(configObj);
        agentObj.refreshConfigration(configString);
      });
      it("should keep agent's metricsConfig and disable agent", function() {
        expect(agentObj.enabledMetrics.size).to.equal(2);
        expect(agentObj.enabledMetrics.has("CPU")).to.equal(true);
        expect(agentObj.enabledMetrics.has("MEMORY")).to.equal(true);
        expect(agentObj.isAgentEnabled).to.equal(false);
      });
    });
    context("when no agent in metricsConfig in config", function() {
      beforeEach(function() {
        var configObj = { "reportInterval": 10, "metricsConfig": {} };
        agentObj.enabledMetrics = new Set(["CPU", "MEMORY"]);
        agentObj.isAgentEnabled = true;
        configString = JSON.stringify(configObj);
        agentObj.refreshConfigration(configString);
      });
      it("should keep agent's metricsConfig and disable agent", function() {
        expect(agentObj.enabledMetrics.size).to.equal(2);
        expect(agentObj.enabledMetrics.has("CPU")).to.equal(true);
        expect(agentObj.enabledMetrics.has("MEMORY")).to.equal(true);
        expect(agentObj.isAgentEnabled).to.equal(false);
      });
    });
    context("when config.reportInterval is not an integer", function() {
      beforeEach(function() {
        var configObj = { "reportInterval": 100, "metricsConfig": { "agent": ["CPU", "MEMORY"] } };
        configObj.reportInterval = "notIntegerString";
        configString = JSON.stringify(configObj);
        agentObj.refreshConfigration(configString);
      });
      it("should log the error", function() {
        expect(console.error.calledOnce).to.be.true;
        expect(console.error.calledWith("[Auto-Scaling Agent] failed to refresh configuration, report interval is not an interger")).to.be.true;
      });
    });
    context("when config contains all fields", function() {
      beforeEach(function() {
        var configObj = { "reportInterval": 10, "metricsConfig": { "agent": ["type1", "type2"] } };
        agentObj.enabledMetrics = new Set(["CPU", "MEMORY"]);
        agentObj.reportInterval = 20000;
        configString = JSON.stringify(configObj);
        agentObj.refreshConfigration(configString);
      });
      it("should change agent's reportInterval,enabledMetrics and enable agent", function() {
        expect(agentObj.reportInterval).to.equal(10000);
        expect(agentObj.enabledMetrics.size).to.equal(2);
        expect(agentObj.enabledMetrics.has("type1")).to.equal(true);
        expect(agentObj.enabledMetrics.has("type2")).to.equal(true);
        expect(agentObj.isAgentEnabled).to.equal(true);
        // expect(console.log.calledWith("we will change report interval from " + 2000 + " to " + 10000)).to.be.true;
      })
    });
  });
  context("sendMetrics", function() {
    var serviceEnv;
    var metricObj;
    beforeEach(function() {});
    context("parameter:serviceEnv", function() {
      context("when serviceEnv is null", function() {
        beforeEach(function() {
          serviceEnv = null;
          agentObj.sendMetrics(serviceEnv, metricObj);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv is not found or empty')).to.be.true;
        });
      });
      context("when serviceEnv is undefined", function() {
        beforeEach(function() {
          agentObj.sendMetrics(serviceEnv, metricObj);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv is not found or empty')).to.be.true;
        });
      });
      context("serviceEnv.agentUserName", function() {
        context("when serviceEnv.agentUsername is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentUsername = null;
            agentObj.sendMetrics(serviceEnv, metricObj);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv.agentUsername is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.agentUsername is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentUsername = undefined;
            agentObj.sendMetrics(serviceEnv, metricObj);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv.agentUsername is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.agentPassword", function() {
        context("when serviceEnv.agentPassword is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentPassword = null;
            agentObj.sendMetrics(serviceEnv, metricObj);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv.agentPassword is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.agentPassword is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentPassword = undefined;
            agentObj.sendMetrics(serviceEnv, metricObj);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv.agentPassword is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.url", function() {
        context("when serviceEnv.url is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.url = null;
            agentObj.sendMetrics(serviceEnv, metricObj);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv.url is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.url is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.url = undefined;
            agentObj.sendMetrics(serviceEnv, metricObj);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:serviceEnv.url is not found or empty')).to.be.true;
          });
        });
      });
    });
    context("parameter:metricObj", function() {
      context("when metricObj is null", function() {
        beforeEach(function() {
          serviceEnv = serviceEnvObj;
          metricObj = null;
          agentObj.sendMetrics(serviceEnv, metricObj);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:metricObj is not found or empty')).to.be.true;
        });
      });
      context("when metricObj is undefined", function() {
        beforeEach(function() {
          serviceEnv = serviceEnvObj;
          metricObj = undefined;
          agentObj.sendMetrics(serviceEnv, metricObj);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] sendMetrics:metricObj is not found or empty')).to.be.true;
        });
      });
    });
    context("metricObj is circular structure", function() {
        beforeEach(function() {
          serviceEnv = serviceEnvObj;
          metricObj = { "one": 1 };
          metricObj.two = metricObj;
          agentObj.sendMetrics(serviceEnv, metricObj);
        });
        it("should log the error", function() {
          expect(console.error.calledTwice).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] failed to stringify metricObj')).to.be.true;
        });
      })
      //----
    context("send http request", function() {
      context("Auto-Scaling server return 200", function() {
        beforeEach(function() {
          calculator.latencyStats = {
            'count': 10,
            'sum': 100,
            'average': 1
          };
          calculator.httpStats = {
            'count': 10,
            'duration': 1000,
            'average': 1
          };
          calculator.memoryStats = {
            'count': 10,
            'sum': 100,
            'average': 1
          };
          calculator.cpuStats = {
            'count': 10,
            'sum': 1,
            'average': 1
          };
          calculator.heapStats = {
            'count': 10,
            'usedSum': 100,
            'usedAverage': 1,
            'committed': 10,
            'maxHeap': 10,
            'heapSizeLimit': 10,
            'maxSemiSpace': 10,
            'maxOldSpace': 10
          };
          calculator.throughputStats = {
            'lastCalculateTime': new Date().getTime() - 1000,
            'requestCount': 100,
            'throughput': 10
          };
          serviceEnv = serviceEnvObj;
          metricObj = calculator.calculate();;
          agentObj.sendMetrics(serviceEnv, metricObj);
        });
        it("no error should be logged", function() {
          /***********Here need more test************/
          expect(console.error.callCount).to.equal(0);
        });
      });
    });

  });
  context("notifyStatus", function() {
    var serviceEnv;
    beforeEach(function() {});
    context("parameter:serviceEnv", function() {
      context("when serviceEnv is null", function() {
        beforeEach(function() {
          serviceEnv = null;
          agentObj.notifyStatus(serviceEnv);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv is not found or empty')).to.be.true;
        });
      });
      context("when serviceEnv is undefined", function() {
        beforeEach(function() {
          agentObj.notifyStatus(serviceEnv);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv is not found or empty')).to.be.true;
        });
      });
      context("serviceEnv.agentUserName", function() {
        context("when serviceEnv.agentUsername is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentUsername = null;
            agentObj.notifyStatus(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv.agentUsername is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.agentUsername is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentUsername = undefined;
            agentObj.notifyStatus(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv.agentUsername is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.agentPassword", function() {
        context("when serviceEnv.agentPassword is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentPassword = null;
            agentObj.notifyStatus(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv.agentPassword is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.agentPassword is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentPassword = undefined;
            agentObj.notifyStatus(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv.agentPassword is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.app_id", function() {
        context("when serviceEnv.app_id is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.app_id = null;
            agentObj.notifyStatus(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv.app_id is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.app_id is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.app_id = undefined;
            agentObj.notifyStatus(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] notifyStatus:serviceEnv.app_id is not found or empty')).to.be.true;
          });
        });
      });
    });
    //----
  });
  context("refreshHeartBeat", function() {
    var serviceEnv;
    beforeEach(function() {});
    context("parameter:serviceEnv", function() {
      context("when serviceEnv is null", function() {
        beforeEach(function() {
          serviceEnv = null;
          agentObj.refreshHeartBeat(serviceEnv);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv is not found or empty')).to.be.true;
        });
      });
      context("when serviceEnv is undefined", function() {
        beforeEach(function() {
          agentObj.refreshHeartBeat(serviceEnv);
        });
        it("should log the error", function() {
          expect(console.error.calledOnce).to.be.true;
          expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv is not found or empty')).to.be.true;
        });
      });
      context("serviceEnv.agentUserName", function() {
        context("when serviceEnv.agentUsername is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentUsername = null;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.agentUsername is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.agentUsername is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentUsername = undefined;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.agentUsername is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.agentPassword", function() {
        context("when serviceEnv.agentPassword is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentPassword = null;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.agentPassword is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.agentPassword is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.agentPassword = undefined;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.agentPassword is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.app_id", function() {
        context("when serviceEnv.app_id is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.app_id = null;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.app_id is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.app_id is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.app_id = undefined;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.app_id is not found or empty')).to.be.true;
          });
        });
      });
      context("serviceEnv.service_id", function() {
        context("when serviceEnv.service_id is null", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.service_id = null;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.service_id is not found or empty')).to.be.true;
          });
        });
        context("when serviceEnv.service_id is undefined", function() {
          beforeEach(function() {
            serviceEnv = serviceEnvObj;
            serviceEnv.service_id = undefined;
            agentObj.refreshHeartBeat(serviceEnv);
          });
          it("should log the error", function() {
            expect(console.error.calledOnce).to.be.true;
            expect(console.error.calledWith('[Auto-Scaling Agent] refreshHeartBeat:serviceEnv.service_id is not found or empty')).to.be.true;
          });
        });
      });
    });
  });
});
